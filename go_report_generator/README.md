

# Go Report Generator

[![Go Report Card](https://goreportcard.com/badge/github.com/IgorBayerl/ReportGenerator/go_report_generator)](https://goreportcard.com/report/github.com/IgorBayerl/ReportGenerator/go_report_generator)

This project is a Golang port of the highly popular .NET coverage analysis tool, [ReportGenerator](https://github.com/danielpalme/ReportGenerator). It aims to replicate the core functionality of the original tool while leveraging the benefits of Go, such as creating a single, self-contained executable.

## Table of Contents

- [About The Project](#about-the-project)
- [Core Concepts](#core-concepts)
- [Feature Status](#feature-status)
  - [Input Formats](#input-formats)
  - [Output Formats](#output-formats)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Installation & Running the Demo](#installation--running-the-demo)
- [Project Structure](#project-structure)
- [Contributing](#contributing)
  - [The Goal of a Parser: Translation](#the-goal-of-a-parser-translation)
  - [The Common Language: Our Internal Data Model](#the-common-language-our-internal-data-model)
  - [How to Add a New Report Parser](#how-to-add-a-new-report-parser)
- [Roadmap](#roadmap)
- [License](#license)

## About The Project

`go-report-generator` was born from several motivations:

1.  **Portability:** To create a single, dependency-free executable for coverage report generation, which is a natural strength of Golang. This simplifies deployment in CI/CD pipelines and cross-platform environments.
2.  **A Case Study:** This project serves as a practical learning experience in porting a large, object-oriented .NET application to Golang, mirroring challenges faced in professional software development.
3.  **Future Innovation:** The long-term vision is to build a new, more powerful HTML visualization layer on top of this Go backend. This new frontend will support advanced features like complex filtering and the ability to trace a line of code back to the specific test(s) that covered it.

Currently, the project focuses on achieving feature parity with the core parsing and reporting capabilities of the original `ReportGenerator`.

## Core Concepts

The HTML reports generated by this tool use a hybrid architecture that combines a Go-powered backend with a sophisticated Angular SPA frontend.

-   **Go Backend:** The Go application is responsible for:
    1.  Parsing various code coverage report formats (currently Cobertura XML).
    2.  Analyzing and merging the coverage data into a unified internal model.
    3.  Generating static HTML files that serve as a shell for the report.
    4.  Serializing the processed coverage data into JavaScript objects and injecting them into a `<script>` tag within the generated HTML.

-   **Angular Frontend:**
    1.  The `go_report_generator/angular_frontend_spa` directory contains a complete Angular application, which is a direct copy from the original `ReportGenerator` project.
    2.  This SPA is responsible for all the dynamic and interactive parts of the report.
    3.  When a user opens a generated HTML file, the browser executes the Angular app, which reads the coverage data from the global `window` object and renders the interactive tables, charts, and source code views.

This approach allows us to reuse the excellent and mature frontend from the original project while building a new, portable backend in Go.

## Feature Status

This section tracks the current progress of the Go port compared to the original C# project's core features.

### Input Formats

The ability to parse different coverage report formats.

| Format      | Status |
|-------------|:------:|
| `Cobertura` |  [x]   |
| `OpenCover` |  [ ]   |
| `dotCover`  |  [ ]   |
| `VS`        |  [ ]   |
| `JaCoCo`    |  [ ]   |
| `lcov`      |  [ ]   |
| `gcov`      |  [ ]   |

### Output Formats

The ability to generate reports in different output formats.

| Format        | Status |
|---------------|:------:|
| `Html`        |  [x]   |
| `TextSummary` |  [x]   |
| `Xml`         |  [ ]   |
| `Json`        |  [ ]   |
| `Csv`         |  [ ]   |
| `Latex`       |  [ ]   |
| `Badge`       |  [ ]   |

*Note: Plugin/extension support from the original tool is not planned for this port.*

## Getting Started

To get the project running and see it in action, you'll need to set up the prerequisites and run the included test orchestration script.

### Prerequisites

You will need the following tools installed on your system:

-   **Go:** To build and run the report generator itself.
-   **.NET SDK:** To build and run the C# sample project for generating test coverage data.
-   **Node.js & npm:** To build the Angular SPA frontend.
-   **gocover-cobertura:** A tool to convert Go's native coverage format to Cobertura XML.
    ```bash
    go install github.com/t-yuki/gocover-cobertura@latest
    ```

### Installation & Running the Demo

The `Testprojects/generate_reports.py` script automates the entire process of testing the Go report generator against both a C# and a Go project.

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/IgorBayerl/ReportGenerator.git
    cd ReportGenerator
    ```

2.  **Build the Angular SPA (Crucial First Step!):**
    The Go application copies the built Angular assets when generating the HTML report. You must build it first.
    ```bash
    cd go_report_generator/angular_frontend_spa/
    npm install
    npm run build
    cd ../../
    ```

3.  **Run the Demonstration Script:**
    This Python script performs a full end-to-end test:
    -   It generates Cobertura coverage reports for a sample C# project and a sample Go project.
    -   It then feeds these Cobertura reports into **both** the original C# `ReportGenerator.dll` (if available) and our new `go_report_generator`.
    -   This allows for a side-by-side comparison of the generated reports.

    Navigate to the `Testprojects` directory and run the script:
    ```bash
    cd Testprojects/
    python generate_reports.py
    ```
    *Note: On some systems, you may need to use `python3` instead of `python`.*

4.  **View the Results:**
    After the script finishes, you will find four new report directories inside the `reports/` folder at the project root:
    -   `reports/csharp_project_go_tool_report/`: Report for the C# project, generated by our Go tool.
    -   `reports/csharp_project_dotnet_tool_report/`: Report for the C# project, generated by the original .NET tool.
    -   `reports/go_project_go_tool_report/`: Report for the Go project, generated by our Go tool.
    -   `reports/go_project_dotnet_tool_report/`: Report for the Go project, generated by the original .NET tool.

    Open the `index.html` file in each directory to compare the outputs.

## Project Structure

The project is organized to maintain a clear separation of concerns, mirroring some of the best practices from the original tool.

```
.
├── go_report_generator/
│   ├── cmd/main.go                     # Main application entry point and CLI logic
│   ├── internal/                       # All core application logic
│   │   ├── model/                      # The common, unified data model for coverage
│   │   ├── parser/                     # Parser interfaces and factories
│   │   │   └── cobertura/              # Example: Implementation for Cobertura format
│   │   ├── reporter/                   # Reporter (builder) interfaces and factories
│   │   │   ├── htmlreport/             # Logic for building HTML reports
│   │   │   └── textsummary/            # Logic for building text summary reports
│   │   ├── inputxml/                   # Go structs mapping to input XML formats
│   │   └── ... (other core packages)
│   └── angular_frontend_spa/           # The Angular SPA for the HTML report
├── src/ReportGenerator.Core/           # Reference C# source code from the original project
└── Testprojects/
    ├── generate_reports.py             # The automation script
    ├── CSharp/                         # A sample C# project
    └── Go/                             # A sample Go project
```

## Contributing

We welcome contributions! The project is designed to be modular, making it easy to add support for new formats. Here’s how you can contribute, using the example of adding a new report parser.

### The Goal of a Parser: Translation

Think of a parser as a **translator**. It takes a specific coverage report format (like *OpenCover*, *dotCover*, etc.) and translates it into a common language that the rest of our application understands. This common language is our internal data model.

### The Common Language: Our Internal Data Model

Before you write a translator, you need to know the language you're translating *to*. In our case, this is a set of Go structs defined in the `internal/model/` package. The key structs are:

-   `model.Assembly`: Represents a compiled project or library.
-   `model.Class`: A class within an assembly.
-   `model.CodeFile`: A single source code file.
-   `model.Line`: A line of code, containing its hit count and any branch information.

Your main goal when writing a new parser is to read data from your input file and populate these structs.

### How to Add a New Report Parser

Let's say you want to add support for a new XML format called "CustomFormat".

#### Step 1: Define the Input Format's Structure

First, create Go structs that mirror the XML structure of "CustomFormat". This lets you easily unmarshal the file. These structs should live in `internal/inputxml/` to keep them separate from our core model.

-   Create a new file: `internal/inputxml/customformat.go`
-   Add your structs with XML tags, e.g., `type CustomRoot struct { ... }`.

#### Step 2: Create the Parser Directory and Files

Organize your new parser's code in its own dedicated directory.

```
go_report_generator/
└── internal/
    └── parser/
        ├── ... (other parsers)
        └── customformat/      <-- New directory for your parser
            ├── parser.go      <-- Your main parser logic will live here
            └── processing.go  <-- (Optional) Helper functions
```

#### Step 3: Implement the `IParser` Interface

In `parser.go`, create your parser struct and make it implement the `parser.IParser` interface. This is the contract all parsers must follow.

```go
// in internal/parser/customformat/parser.go
package customformat

import (
    "github.com/IgorBayerl/ReportGenerator/go_report_generator/internal/parser"
    "github.com/IgorBayerl/ReportGenerator/go_report_generator/internal/reporting"
    // Import your inputxml and model packages
)

type CustomFormatParser struct{}

// NewCustomFormatParser creates a new parser instance.
func NewCustomFormatParser() parser.IParser {
    return &CustomFormatParser{}
}

// Name returns the friendly name of the parser.
func (p *CustomFormatParser) Name() string {
    return "CustomFormat"
}

// SupportsFile quickly checks if a file is in the format your parser can handle.
func (p *CustomFormatParser) SupportsFile(filePath string) bool {
    // e.g., check for a unique root element or file extension.
    return true // Placeholder
}

// Parse is the main translation function.
func (p *CustomFormatParser) Parse(filePath string, context reporting.IReportContext) (*parser.ParserResult, error) {
    // 1. Read and unmarshal the XML file into your structs from Step 1.
    // 2. Loop through the unmarshaled data.
    // 3. Create and populate instances of model.Assembly, model.Class, etc.
    // 4. Return a `parser.ParserResult` containing the translated data.
    return &parser.ParserResult{}, nil // Placeholder
}
```

#### Step 4: Register Your Parser

Finally, make the application aware of your new parser. In the same `parser.go` file, add an `init()` function to register your parser with the central factory.

```go
// in internal/parser/customformat/parser.go

func init() {
    // This line automatically tells the application about your new parser
    parser.RegisterParser(NewCustomFormatParser())
}
```

That's it! The application can now automatically detect and use your new parser for "CustomFormat" reports.

## Roadmap

-   [ ] **Add More Parsers:** Implement parsers for other major formats like OpenCover, dotCover, and JaCoCo to reach feature parity.
-   [ ] **Add More Reporters:** Implement builders for other formats like `XML`, `JSON`, `Latex` and `Badge`.
-   [ ] **Enhance Testing:** Add more unit and integration tests to cover the parsing and rendering logic, enabling safer refactoring.
-   [ ] **Implement History/Diff:** Fully wire up the historic coverage analysis to enable trend charts and diff reports.
-   [ ] **Implement Risk Hotspots:** Complete the risk hotspot analysis based on cyclomatic complexity and other metrics.
-   [ ] **Develop New Frontend:** Begin work on the next-generation HTML report with advanced features.

## License

This project is licensed under the MIT License - see the `LICENSE` file for details.